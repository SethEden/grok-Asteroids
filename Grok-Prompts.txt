Ok I've been working with you for a few days now to build a multi-monitor 2D arcade game engine for Windows using NodeJS, ElectronJS, VueJS, and BabylonJS. We have done some really amazing and difficult things!! After much effort I have managed to get all of the multi-monitor cameras for each of the different application windows to have their view frustum aligned and projected perfectly against the Z=0 XY-Plane. I also managed to get the mouse coordinates perfectly transformed into world coordinates via a view transform. So I do NOT want to touch any of those things any more, as any changes there is likely to only cause regressions in either the camera locations, view frustums, or the camera target vectors, or the mouse screen-space coordinates to world space coordinates transformation. As part of that effort we really struggled with BabylonJS because apparently the ortho-camera does not support rendering of geometry for version 7.50.0, or version 6.0.0 with our specific tech stack. Not sure what is going on there, but we worked around it with everything I described above switching to a free camera instead. So I would like to setup some ground rules before we get any further. #1. I want to make sure that we are always using JavaScript ES6/ES7 syntax with modern import/export statements. #2. I want to make sure we completely avoid any usage of the term "this" in the code as it can confuse scope and cause issues with maintainability, future development efforts or code support, and tech debt. #3. I want to make sure we are always and ONLY using a compositional programing model! So none of this inheritance, or polymorphism messy business. Lets try and keep the code simple and clean. Now with all of that out of the way, I can tell you the files I have so far, and I am happy to share the current contents of each file as we work on this together. The current status is a very basic base 2D game engine where a sprite object tracks the mouse movement across the game space....and there is a green vector plane object in the center of the screen. Now the goal is to build a basic line-vector object multi-monitor remake of the classic game asteroids. So there will be object collision, player movement, targeting, shooting bullets, generating objects, destroying objects, spawning new objects as they break up, and a wrap-around game space. A player ship with thrusters....and more. Later on we will need lives, power up rewards to gain new lives, a scoring system, a way to track level difficulty as the user completes levels, and new more difficult levels are loaded, a menu system. But right now I just want to make sure we can get the most basic game mechanics functioning. So the files I have so far are as follows: src/components/position.js, src/components/renderable.js, src/components/velocity.js, src/systems/aiming.js, src/systems/collision.js, src/systems/firing.js, src/systems/input.js, src/systems/movement.js, src/systems/rendering.js, src/engine.js, src/entities.js, src/main-renderer.js, src/main.js, src/renderer.js, src/state.js. :: Again I want to make sure that all of the game objects and player ship, bullets and everything are built with 2D vector based primitive objects or custom 2D mesh based vector objects.....not sprites. So that should be enough information for us to get started.....LETS GO!! I think the first order of business is probably to remove the sprite object, and perhaps replace it with a vector based target line object.....and then replace the green square with a triangle shaped vector mesh object that can represent the player ship. Going for a classic simple black and white asteroid vibe here! I don't want you to start making recommendations on the code changes until you get a chance to take a look at the code I already have....so lets take this one step at a time and you let me know which code files you think you need to look at, and then I can share them and we can collaborate this way. Also another few points I want to bring out. 1. We decided we need to shift to a new strategy where there is a single BabylonJS scene where all of the game objets are stored, and then each display window will ensure that the cameras are looking at this same scene. Then the only events we need to synchronize between windows is for interactions such as mouse movements, key press events, windows focus changes, those kinds of things. This will greatly simplify the entire game system. 2. We learned that BabylonJS needs to have at least 1 basic camera and full rendering stack setup, so we decided to use the control window as a dummy to get everything setup before mounting all the other windows to that scene, then the dummy window can be deleted to prevent any garbage collection from disposing of objects.

Now for the latest updates from our last session....we were having some impossible issues trying to get the engine.js mounted....so I went offline and worked on it for some time until I got the engine.js working. I had to remove a bunch of stuff just to get it working at the most basic level. So I made a backup of the old engine.js now called "engine copy.js". I believe this had all of our camera coordinate transformation calculations which took several days to figure out so I want to make sure not to loose all of that critical information. Now we are trying to work on a multi-stage bootstap process that will essentially initialize the BabylonJS scene space with the generic control window, and using some kind of a semaphore or mutex system flag that the initial bootup process is completed, then all the real display data can be sent over for additional processing without trying to cram everything into a single startup stage with an already delicate communication channel between the main.js process, the renderer.js process and the engine.js process. We have removed the sprite and the green square, we did all of the camera calulations for the camera positions and camera target coordinates, the camera FOV calculations and the camera frustum calculations to get them adjacent aligned at the Z=0 axis. All of that work was done with the file "engine copy.js" So the next major task is to migrate and integrate all of those camera calculations which took an entire day oer to the engine.js file and make sure that all the cameras are rendering to their respective canvas objects in the application. That is what I need your help with next! So now are you ready to resume work?